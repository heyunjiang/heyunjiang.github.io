## 函数柯里化

### 定义

将一个使用多个参数的函数转换成一系列使用一个参数的函数

### 用途

参数服用，提高适用性，降低通用性

### 第一版

```
function curry(fn) {
    var args = [].slice.call(arguments, 1);
    return function() {
        return fn.apply(this, args.concat([].slice.call(arguments)));
    };
}

function add(a, b) {
    return a + b;
}

var addCurry = curry(add, 1, 2);
addCurry() // 3
//或者
var addCurry = curry(add, 1);
addCurry(2) // 3
//或者
var addCurry = curry(add);
addCurry(1, 2) // 3
```
实现了参数的预置，只能柯里化之后调用一次，没有实现add(1)(2)(3)功效

### 第二版

```
function sub_curry(fn) {
    var args = [].slice.call(arguments, 1);
    return function() {
        return fn.apply(this, args.concat([].slice.call(arguments)));
    };
}

function curry(fn, length) {

    length = length || fn.length;

    var slice = Array.prototype.slice;

    return function() {
        if (arguments.length < length) {
            var combined = [fn].concat(slice.call(arguments));
            return curry(sub_curry.apply(this, combined), length - arguments.length);
        } else {
            return fn.apply(this, arguments);
        }
    };
}

var fn = curry(function(a, b, c) {
    return [a, b, c];
});

fn("a", "b", "c") // ["a", "b", "c"]
fn("a", "b")("c") // ["a", "b", "c"]
fn("a")("b")("c") // ["a", "b", "c"]
fn("a")("b", "c") // ["a", "b", "c"]
```

注意点：
1. apply传参第二个参数为数组，call参数逗号分隔的
2. 每次调用时参数是保存在sub_curry的args里面的
3. 这里用到了2处闭包，sub_curry和curry，每次返回的是函数，2处分别保存了args和length变量

### 第三版 es6

```
var curry = fn =>
    judge = (...args) =>
        args.length === fn.length ? fn(...args) : (arg) => judge(...args, arg)
```


## 总结

闭包： 保存变量值

返回函数： 熟悉了返回函数，以前全部返回值或执行一个过程

递归： 不满足最终条件？递归：结束递归

## 应用场景

1. 延迟执行：待执行函数的参数需要通过不同途径获取，参数个数达到上限时才执行
2. 参数复用：有几个共同的参数，参数没有上限，传多少就执行多少
3. 降低环境判断次数，提前返回：比如对浏览器支持事件绑定判断