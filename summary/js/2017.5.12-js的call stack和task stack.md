## 浏览器如何执行js代码

```
console.log(new Date);
for (var i = 0; i < 5; i++) {
    setTimeout(function() {
      console.log(new Date, i);
    }, 1000);
}
console.log(new Date, i);

```

执行顺序

1. 读取第一行 `console.log(new Date);` ，加入call stack；
2. 执行，出栈，直接输出日期；
3. 循环，读取第一个 `setTimeout`，加入call stack；
4. 执行，发现是 setTimeout异步执行，出栈，加入timer模块；
5. 循环5次，出循环，读取最后一行，加入call stack；
6. 执行，出栈，直接输出日期和i，此时i=5；
7. 在循环将定时器加入timer模块的时候，timer模块就开始定时，同时执行5个定时器，不是一个定时器执行完了才执行下一个，timer模块直接启动5个定时，定时1s结束，依次加入任务队列 `task queue`；
8. 在call stack没有任务的时候，就执行 task queue。

所以依次输出： 5，隔一秒，同时输出5个5

### 要点总结

在浏览器内核解析执行js代码的时候，会采用3个模块执行

1. call stack：调用栈，任何代码都会经历入栈、出栈
2. web api处理模块：在处理dom event，ajax，setTimeout定时器这三种的时候，会启动不同的模块。在webkit内核中，这个处理模块叫做webcore，提供了DOM Binding,network,timer这3个模块来底层实现。
3. task queue：任务队列，经过web api处理模块处理过后的代码，会被扔进任务队列。在call stack执行完毕之后，就会来调用任务队列。

关键点： 浏览器会采用3个模块来处理js代码的事件循环。

### 补充

task queue细分为：macro task，micro task

macro task: scirpt(整体代码)、setTimeout、setInterval、I/O、UI rendering;
micro-task: promises

加入到task queue的，会首先执行micro task，后执行 macro task


### 自我评价

以前自己只知道浏览器维护了一个任务队列，所有异步处理都会放在这个任务队列里面，在主线程空闲的时候，再来执行这个任务队列。

现在深入学习知道了： 浏览器提供web api处理模块来处理所有的异步操作，然后才把最终需要执行的代码丢入任务队列。

异步处理经历流程： call stack->webcore->task queue